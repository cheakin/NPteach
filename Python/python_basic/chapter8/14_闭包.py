
# 闭包： 内层函数 + 被外层函数所引用的外层变量
# 闭包产生的条件:
# 1.要有函数嵌套。
# 2.在[内层函数]中，要访问[外层函数]的变量。
# 3.并且[外层函数]要返回[内层函数]。

# def outer():
#     num = 10
#     print(hex(id(num)))
#
#     def inner():
#         nonlocal num
#         num += 1
#         print(num)
#
#     return inner
#
# f = outer()
# f() # 不会报错。inner是内层函数，外层函数调用结束了，但仍然能打印外层函数的变量
# f()
#
# # 打印 __closure__ 元组
# print(f.__closure__) # 函数的变量地址，和外层函数的变量地址是相同的
#
# # 注意点1.调用n次外层函数，就会得到n个不同的闭包，并且这些闭包之间互不影响
# # 注意点2.内层函数中用到的外层变量是可变对象，多个闭包之间依然互不影
# f1 = outer()
# f1()
# f1()
# print('***********')
# f2 = outer()
# f2()
# f2()


#闭包的优点:
#1.可以"记住"状态:不用全局变量，也不用写类，就能在多次调用之间保存数据。
#2.可以做"配置过的函数":先传一部分参数，把环境固定住，得到一个定制版函数。
#3.可以实现简单的"数据隐藏":外层变量对外不可见，只能通过内层函数访问。
# 4.是装饰器(decorator)等高级用法的基础。
def beautiful(char, n):
    def show_msg(msg):
        print(char *  n + msg + char * n)
    return show_msg

show1 = beautiful('*', 3)
show1('你好啊！')
show1('新年好！！！')


#闭包的缺点:
#1.理解成本较高:对初学者不太友好，滥用会让代码难读。
#2.如果闭包里引用了很大的对象，又长期不释放，可能会增加内存占用。
#3.很多场景下，其实用[类+实例属性]会更清晰，闭包不一定是最优解。




